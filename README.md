# Лабораторная работа №6

В данной лабораторной работе вам предстоит собрать и запустить готовое клиент-серверное приложение на java в докере.
также, сервер использует базу данных PostgreSQL, все инструкции и справки представлены ниже. 


## Справочная информация

#### Установка Docker:
разнится от ОСи, на которой вы сидите. По ходу лабы пользуйтесь (оффициальным сайтом)[https://docs.docker.com/], где собраны мануалы/примеры/решения ваших проблем. Если никогда не работали с докером - рекомендую начать с Docker Desktop. Любые проблемы гуглятся, а что не гуглится - решается лично.

#### Docker: Основные команды
| | |
|-|-|
| Запуск контейнера            | `docker run [OPTIONS] IMAGE_NAME` |
| Список активных контейнеров  | `docker ps` |
| Просмотр логов контейнера    | `docker logs CONTAINER_NAME`  |
| Перезапуск контейнера        | `docker restart CONTAINER_NAME` |
| Мониторинг ресурсов          | `docker stats` |
| Ограничение ресурсов         | `docker run --memory=256m --cpus=1 IMAGE_NAME` |
| | |

[Подробнее о командах](https://docs.docker.com/engine/reference/commandline/cli/)

### Docker Network
Для связи между контейнерами рекомендуется использовать внутренние сети Docker:
- *Создание сети*: `docker network create my_network`
- *Подключение\[Отключение\] контейнера к сети*: `docker network connect[disconnect] my_network CONTAINER_NAME`
- *Просмотр списка сетей*: `docker network ls`

[Подробнее о взаимодействии контейнеров с сетью](https://docs.docker.com/engine/network/)

---

### Dockerfile: Основные инструкции
Dockerfile содержит последовательность команд для создания Docker-образа. 
Некоторые из них:
- `FROM`: задаёт базовый образ.
- `COPY`: копирует файлы из хостовой системы внутрь контейнера.
- `WORKDIR`: устанавливает рабочую директорию внутри контейнера.
- `RUN`: выполняет команды на этапе сборки образа.
- `CMD`: задаёт команду, выполняемую при запуске контейнера.
- `EXPOSE`: указывает порты, которые будут открыты для доступа.
- `ENV`: задаёт переменные окружения.

[Поробнее о Dockerfile](https://docs.docker.com/reference/dockerfile/)

**Пример многоступенчатой сборки:**
```dockerfile
# Этап сборки приложения
FROM img1 as builder
COPY src(on host) target(on image)
RUN ./build.sh 

# Этап запуска приложения
FROM img2 as runner
COPY --from=builder /build/file /run/file
CMD ["bash", "/run/run.sh"]
```

---

### Подключение базы данных
Для работы сервера необходима база данных PostgreSQL. Рекомендуемый образ - `postgres:15`. При запуске укажите параметры:
- Имя пользователя (`POSTGRES_USER`).
- Пароль (`POSTGRES_PASSWORD`).
- Имя базы данных (`POSTGRES_DB`).

Инициализация бд выполняется с помощью SQL-скрипта, который смонтирован по пути `/docker-entrypoint-initdb.d/initdb.sql`:

Все параметры расписаны в конфигурации по пути `RG_LAB7/src/main/java/p3111/redgry/lab7/Config.java`, в том числе имя контейнера с базой данных.

### подсказка
вы должны прочитать файл конфигурации и понять, как называть сети и контейнеры.

При перезапуске контейнера база данных все внесенные изменения в бд исчезнут - сохраните их.

[Официальная документация PostgreSQL Docker Image](https://hub.docker.com/_/postgres).

---

## Задачи

### 1. Сборка приложения
1. Исходный код приложения использует систему сборки *Maven*.
2. Используйте базовый образ сборщика: `maven:3.8.5-openjdk-17`.
3. Исходный java-код находится в RG_LAB7/src
4. Команда для сборки jar-файла *(далее - джарник)*:
   ```bash
   mvn clean package
   ```
5. После сборки джарник появится в директории `target`.

---

### 2. Создание контейнеров
- **Сервер**:
  - Базовый образ: `openjdk:17-jdk-slim`.
  - Контейнер обязан называться `lab7-server`.
- **Клиент**:
  - Базовый образ: тоже `openjdk:17-jdk-slim`.

Клиент и сервер используют одну кодовую базу *(ps: конструктивная особенность исходной лабы)* и имеют несколько точек входа, поэтому при запуске необходимо ее указать:

```bash
java -cp app_name.jar p3111.redgry.lab7.Client(Server)
```

---

### 3. Использование многоступенчатой сборки
Разделите процесс на два этапа:
1. **Сборка** (используйте `maven:3.8.5-openjdk-17`).
2. **Запуск** (используйте `openjdk:17-jdk-slim`).

---

## Проверка работы
0. Все команды можно записать в .sh скрипты, но на защите могу попросить воспроизвести их
1. Соберите приложение и запустите контейнеры.
2. Убедитесь, что:
   - Перед сервером вы запускаете базу данных
   - Контейнеры работают во внутренней сети.
   - База данных сохронит свое состояние после перезапуска
3. Проверьте мониторинг ресурсов с помощью `docker stats`.

---

## Вопросы для защиты

1. Отличия `RUN` от `CMD` от `ENTRYPOINT`
2. Что такое слои и зачем они кэшируютс
3. Многослойная сборка - как и зачем?
4. Образ или контейнер?
5. Операции с запущенными контейнерами


#### траблшутинг
Если у вас выскакивает проблема вида NoClassDefFoundError: .../log4j/LogManager - значит вы неправильно закинули файлы в образ. спойлер - `COPY . .` не сработает! вы должны закинуть в рабочую дирректорию `src` и `pom.xml` 

#### Послесловие

За основу была взята [вот эта лаба](https://github.com/RedGry/ITMO/tree/master/Programming/LAB_7), вроде как одна из самых популярных на вт. Однако, она имеет ряд веселых конструктивных особенностей, которые заставили меня переписать половину исходников, дабы это чудо стабильно запускалось. Подразумевалось, что после выполнения лабы, вы сможете потыкать сие творение, но, к сожалению, она не работает так как задумано изначально. На выполнение данной лабы это никак не влияет, но если будете тыкаться в само приложение - могут вылетать непонятные ошибки.

Цель лабы - показать, что используя docker или иные технологии контейнеризации в повседневной жизни, можно сильно упрощать себе жизнь и (почти) не зависить от окружения и оси при использовании чего либо - будь то алгосы и mlpack или обучения модели в облаке без изначально настроенного окружения. 

В дальнейшем вы будете сталкиваться с контейнеризацией намного чаще, чем можете сейчас себе представить.
